<html lang="en">
<head>
    <title>Benchmark of Web Templating Engines (Stress Test)</title>
    <style>
        body{
            /*
            background-color: #111;
            color: #aaa;
            */
            font-family: Arial, Helvetica, sans-serif;
            font-weight: 300;
            line-height: 26px;
            font-size: 100%;
        }
        h1{
            padding-top: 10px;
        }
        td{
            text-align: right;
        }
        td:first-of-type{
            text-align: left;
        }
    </style>
</head>
<body>
<h1>Benchmark of Web Templating Engines (Stress Test)</h1>
<hr>
<table cellpadding="5" cellspacing="5">
    <thead>
        <tr>
            <th>Library</th>
            <th>Size</th>
            <th>Memory</th>
            <th>Create</th>
            <th>Replace</th>
            <th>Update</th>
            <th>Repaint</th>
            <th>Append</th>
            <th>Remove</th>
            <th>Toggle</th>
            <th>Clear</th>
            <th>Score</th>
            <th>Index</th>
        </tr>
    </thead>
    <tbody id="result"></tbody>
</table>
<br>
To measure memory you have to run in Chrome browser.<br><br>
<b>Single Tests:</b>
<ul>
    <li><a href="test/domc/">domc</a></li>
    <li><a href="test/inferno/">inferno</a></li>
    <li><a href="test/mikado/">mikado</a></li>
    <li><a href="test/redom/">redom</a></li>
    <li><a href="test/sinuous/">sinuous</a></li>
    <li><a href="test/surplus/">surplus</a></li>
    <li><a href="test/innerhtml/">innerHTML (native)</a></li>
    <li><a href="test/jquery/">jquery</a></li>
    <li><a href="test/mithril/">mithril</a></li>
    <li><a href="test/knockout/">knockout</a></li>
    <li><a href="test/lit-html/">lit-html</a></li>
    <li><a href="test/ractive/">ractive</a></li>
</ul>
<br>
<iframe id="iframe" hidden></iframe>
<script src="test/mikado/dist/mikado.light.js"></script>
<script src="tpl/row.js"></script>
<script>

    (function(){

        const iframe = document.getElementById("iframe");
        const result = document.getElementById("result");
        const mikado = Mikado.new(result, "row", { cache: false, store: false, pool: false });

        const lib = shuffle([
            "mikado", "domc", "inferno",
            "redom", "sinuous", "surplus",
            "innerHTML", "jquery", "mithril",
            "knockout", "lit-html", "ractive"
        ]);

        const test = [
            "size", "memory", "create",
            "update", "partial", "repaint",
            "append", "reduce", "toggle",
            "remove"
        ];

        let current = new Array(lib.length);
        let index = -1;

        let size = {

            "mikado": 2.3,
            "domc": 4.46,
            "inferno": 8.4,
            "redom": 2.88,
            "sinuous": 7.48,
            "surplus": 15.79,
            "innerHTML": 0,
            "jquery": 31.26,
            "mithril": 9.64,
            "knockout": 24.8,
            "lit-html": 17.31,
            "ractive": 68.2
        };

        let memory = {

            "mikado": 16487,
            "domc": 108992,
            "inferno": 238827,
            "redom": 363451,
            "sinuous": 264323,
            "surplus": 189611,
            "innerHTML": 476345,
            "jquery": 642049
        };

        for(let x = 0; x < lib.length; x++){

            current[x] = {

                "name": lib[x],
                "size": size[lib[x]],
                "memory": 0,
                "score": "",
                "index": ""
            };

            for(let y = 2; y < test.length + 1; y++){

                current[x][test[y]] = "";
                current[x]["color_" + test[y]] = "transparent";
            }
        }

        mikado.render(current);

        function runner(){

            index++;
            current[index][test[2]] = "run...";
            mikado.update(mikado.node(index), current[index]);
            iframe.src = "test/" + lib[index].toLowerCase() + "/";
        }

        function get_score(){

            let max = new Array(test.length);
            let val = new Array(test.length);

            for(let y = 0; y < test.length; y++){

                max[y] = 0;
                val[y] = [];

                for(let x = 0; x < lib.length; x++){

                    if(current[x][test[y]]){

                        val[y].push(current[x][test[y]]);
                    }
                    else if(test[y] === "memory"){

                        val[y].push(memory[lib[x]]);
                    }

                    if((test[y] === "size") || (test[y] === "memory")){

                        if((test[y] === "memory") && !current[x][test[y]]){

                            current[x][test[y]] = memory[lib[x]];
                        }

                        if(current[x][test[y]] && ((current[x][test[y]] < max[y]) || !max[y])){

                            max[y] = current[x][test[y]];
                        }
                    }
                    else{

                        if(current[x][test[y]] > max[y]){

                            max[y] = current[x][test[y]];
                        }
                    }
                }
            }

            let score = new Array(lib.length);
            let index = new Array(lib.length);
            let max_score = 0, max_index = 0;

            for(let x = 0; x < lib.length; x++){

                score[x] = 0;
                index[x] = 0;

                for(let y = 0; y < test.length; y++){

                    if((test[y] === "size") || (test[y] === "memory")){

                        if(current[x][test[y]]){

                            if(test[y] === "size"){

                                score[x] += Math.sqrt(average(val[y]) / current[x][test[y]]);
                                index[x] += Math.sqrt(max[y] / current[x][test[y]]);
                                current[x]["color_" + test[y]] = color(Math.sqrt(max[y]), Math.sqrt(current[x][test[y]]));
                            }
                            else{

                                score[x] += average(val[y]) / current[x][test[y]];
                                index[x] += max[y] / current[x][test[y]];
                                current[x]["color_" + test[y]] = color(max[y], current[x][test[y]]);
                            }
                        }
                    }
                    else{

                        score[x] += current[x][test[y]] / average(val[y]);
                        index[x] += current[x][test[y]] / max[y];
                        current[x]["color_" + test[y]] = color(current[x][test[y]], max[y]);
                    }
                }

                current[x]["score"] = (score[x] / (test.length - (lib[x] === "innerHTML" ? 1 : 0)) * 1000 + 0.5) | 0;
                current[x]["index"] = (index[x] / (test.length - (lib[x] === "innerHTML" ? 1 : 0)) * 1000 + 0.5) | 0;
                if(max_score < current[x]["score"]) max_score = current[x]["score"];
                if(max_index < current[x]["index"]) max_index = current[x]["index"];
            }

            for(let x = 0; x < lib.length; x++){

                current[x]["color_score"] = color(current[x]["score"], max_score);
                current[x]["color_index"] = color(current[x]["index"], max_index);
            }
        }

        function color(current, max){

            const percent = current / max * 100;
            const r = percent < 50 ? 255 : (255 - (percent * 2 - 100) * 255 / 100) | 0;
            const g = percent > 50 ? 255 : ((percent * 2) * 255 / 100) | 0;

            return 'rgb(' + r + ', ' + g + ', 0)';
        }

        window.onmessage = function(event){

            if(event.origin === location.protocol + "//" + location.hostname) { // "https://nextapps-de.github.io" "https://raw.githack.com"

                const parts = event.data.split(",");

                current[index][parts[0]] = parseInt(parts[1], 10);
                current[index]["memory"] += parseInt(parts[2], 10);
                mikado.update(mikado.node(index), current[index]);

                if(parts[0] === "remove"){

                    if(index < lib.length - 1){

                        setTimeout(runner, 500);
                    }
                    else{

                        get_score();
                        mikado.render(current);
                    }
                }
                else{

                    current[index][test[test.indexOf(parts[0]) + 1]] = "run...";
                    mikado.update(mikado.node(index), current[index]);
                }
            }
        };

        function shuffle(items){

            for(let i = items.length - 1, j, x; i > 0; i--) {

                j = (Math.random() * i) | 0;
                x = items[i];
                items[i] = items[j];
                items[j] = x;
            }

            return items;
        }

        function median(arr){

            arr.sort(function(a, b){

                return a - b;
            });

            const length = arr.length;
            const half = length / 2;

            return (

                length % 2 ?

                    arr[half | 0]
                :
                    (arr[half - 1] + arr[half]) / 2
            );
        }

        function average(arr){

            const length = arr.length;
            let sum = 0;

            for(let i = 0; i < length; i++){

                sum += arr[i];
            }

            return sum / length;
        }

        setTimeout(runner, 200);
    }());

</script>
</body>
</html>